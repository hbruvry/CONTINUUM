
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Continuum</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<div id="container" style="display: block; width: 100%; height: 100vh;"></div>
		<div id="gui-container" style="position: absolute; top: 0px; left: 0px;"></div>

		<script defer type="module">
			import * as THREE from 'https://unpkg.com/three@0.121.1/build/three.module.js';
			import Stats from 'https://unpkg.com/three@0.121.1/examples/jsm/libs/stats.module.js';
			import { GUI } from 'https://unpkg.com/three@0.121.1/examples/jsm/libs/dat.gui.module.js';
			import { OrbitControls } from 'https://unpkg.com/three@0.121.1/examples/jsm/controls/OrbitControls.js';
			import { FBXLoader } from 'https://unpkg.com/three@0.121.1/examples/jsm/loaders/FBXLoader.js';
			import { ConvexGeometry } from 'https://unpkg.com/three@0.121.1/examples/jsm/geometries/ConvexGeometry.js';
			import { BufferGeometryUtils } from 'https://unpkg.com/three@0.121.1/examples/jsm/utils/BufferGeometryUtils.js';
			import { EXRLoader } from 'https://unpkg.com/three@0.121.1/examples/jsm/loaders/EXRLoader.js';
			
			let container, clock/*, stats*/;
			let camera, controls, scene, renderer;
			let hemiLight, dirLight;

			let modelConvexMesh;
			let modelMesh, modelAnimMixer, modelBoundingBox;
			let modelSkelHelper, modelIcoHelper, modelGuizmoHelper;
			let modelArrowHelperX, modelArrowHelperY, modelArrowHelperZ;
			let guiSettings;
			let path = 'models/fbx/' 
			// let path = 'https://www.hbruvry.com/wp-content/uploads/2021/06/';

			const ui = { timeScale: 1.0 }

			init();
			animate();

			function loadModel( object )
			{
				modelMesh = object;
				modelAnimMixer = new THREE.AnimationMixer( modelMesh );
				modelAnimMixer.clipAction( modelMesh.animations[ 0 ] ).play();

				modelMesh.traverse( function ( child )
				{
					if ( child.isMesh )
						child.castShadow = true;
				} );
				scene.add( modelMesh );

				modelBoundingBox = new THREE.Box3();				
				modelSkelHelper = new THREE.SkeletonHelper( modelMesh );
				scene.add( modelSkelHelper );
			}

			function getBonePosition( index )
			{
				let position;

				position = new THREE.Vector3();
				modelSkelHelper.bones[ index ].getWorldPosition( position );
				return ( position );
			}

			function setModelConvexMesh()
			{
				let vertices = [];
				let geometry, material;

				for ( let i = 0; i < modelSkelHelper.bones.length; i++ )
					vertices.push( getBonePosition( i ) );
				geometry = new ConvexGeometry( vertices );

				material = new THREE.MeshNormalMaterial();
				material.opacity = 0.25;
				material.transparent = true;

				modelConvexMesh = new THREE.Mesh( geometry, material );
				scene.add( modelConvexMesh );
				return ;
			}

			function setArrowHelpers()
			{
				modelArrowHelperX = new THREE.ArrowHelper( new THREE.Vector3( 1.0, 0.0, 0.0 ), new THREE.Vector3(), 20, 0xff0000 );
				modelArrowHelperY = new THREE.ArrowHelper( new THREE.Vector3( 0.0, 1.0, 0.0 ), new THREE.Vector3(), 20, 0xff0000 );
				modelArrowHelperZ = new THREE.ArrowHelper( new THREE.Vector3( 0.0, 0.0, 1.0 ), new THREE.Vector3(), 20, 0xff0000 );
				scene.add( modelArrowHelperX, modelArrowHelperY, modelArrowHelperZ );
				return ;
			}

			function setGuizmoHelper()
			{
				let gridHelperX, gridHelperY, gridHelperZ; 

				modelGuizmoHelper = new THREE.Group();

				gridHelperX = new THREE.GridHelper( 1, 2, 0xff0000, 0xe0e0e0 );
				gridHelperY = new THREE.GridHelper( 1, 2, 0xff0000, 0xe0e0e0 );
				gridHelperZ = new THREE.GridHelper( 1, 2, 0xff0000, 0xe0e0e0 );

				gridHelperY.rotation.x = Math.PI / 2.0;
				gridHelperZ.rotation.z = Math.PI / 2.0;

				gridHelperX.scale.set( 1.0, 1.0, 0.618034 );
				gridHelperY.scale.set( 0.618034, 1.0, 1.0 );
				gridHelperZ.scale.set( 0.618034, 1.0, 1.0 );

				modelGuizmoHelper.add( gridHelperX );
				modelGuizmoHelper.add( gridHelperY );
				modelGuizmoHelper.add( gridHelperZ );
				scene.add( modelGuizmoHelper );
			}

			function setIcoHelper()
			{
				let geometry, wireframe;

				geometry = new THREE.IcosahedronGeometry( 0.5, 0 );
				wireframe = new THREE.WireframeGeometry( geometry );	
				modelIcoHelper = new THREE.LineSegments( wireframe );
				scene.add( modelIcoHelper );
			}

			function setModelHelpers()
			{
				setGuizmoHelper();
				setIcoHelper();
				setArrowHelpers();
				return ;
			}

			function modifyTimeScale( speed )
			{
				modelAnimMixer.timeScale = speed;
				return ;
			}

			function createGUI()
			{
				let gui;
				let folderAnimation;

				gui = new GUI();
				document.getElementById( 'gui-container' ).appendChild( gui.domElement );
				folderAnimation = gui.addFolder( 'Animation settings' );
				folderAnimation.add( ui, 'timeScale', 0.01, 2.0, 0.01 ).listen().onChange( modifyTimeScale );
				return ;
			}

			function init()
			{
				let modelLoader;
				let floorMesh, floorHelper;

				container = document.getElementById( 'container' );
				clock = new THREE.Clock();

				camera = new THREE.PerspectiveCamera( 30, container.clientWidth / container.clientHeight, 1, 5000 );
				camera.position.set( 0, 240, 1200 );
				controls = new OrbitControls( camera, container );
				controls.target.set( 0, 80, 0 );
				controls.update();

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xf8f8ff );
				scene.fog = new THREE.Fog( 0xf8f8ff, 1200, 2000 );

				hemiLight = new THREE.HemisphereLight( 0xf8f8ff, 0x404048 );
				hemiLight.position.set( 0, 240, 0 );
				dirLight = new THREE.DirectionalLight( 0xf8f8ff );
				dirLight.position.set( 0, 240, 120 );
				dirLight.castShadow = true;
				dirLight.shadow.camera = new THREE.OrthographicCamera( 160, -80, -120, 120 );
				scene.add( hemiLight, dirLight );

				floorMesh = new THREE.Mesh( new THREE.PlaneGeometry( 2400, 2400 ), new THREE.MeshPhongMaterial( { color: 0xffffff/*, depthWrite: false*/ } ) );
				floorMesh.rotation.x = -Math.PI / 2.0;
				floorMesh.receiveShadow = true;
				floorHelper = new THREE.GridHelper( 2000, 20, 0xf0f0f0, 0xf0f0f0 );
				scene.add( floorMesh, floorHelper );

				modelLoader = new FBXLoader();
				modelLoader.load( path + 'Samba-Dancing.fbx', function ( object ) {
					loadModel( object );
					setModelConvexMesh();
					setModelHelpers();
				} );

				createGUI();
				// stats = new Stats();
				// container.appendChild( stats.dom );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( container.clientWidth, container.clientHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1.0;
				renderer.shadowMap.enabled = true;
				container.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );
				return ;
			}

			function onWindowResize()
			{
				camera.aspect = container.clientWidth / container.clientHeight;
				camera.updateProjectionMatrix();	
				renderer.setSize( container.clientWidth, container.clientHeight );
				return ;
			}

			function updateModelBbox()
			{
				let min, max;

				min = new THREE.Vector3( Infinity, Infinity, Infinity );
				max = min.clone().multiplyScalar( -1 );
				for (let i = 0, position; i < modelSkelHelper.bones.length; i++ )
				{
					position = getBonePosition( i );
					if ( position.x < min.x ) min.x = position.x;
					if ( position.y < min.y ) min.y = position.y;
					if ( position.z < min.z ) min.z = position.z;
					if ( position.x > max.x ) max.x = position.x;
					if ( position.y > max.y ) max.y = position.y;
					if ( position.z > max.z ) max.z = position.z;
				}
				modelBoundingBox.set( min, max );
				return ;
			}

			function getIcosahedronEdge( center, angle )
			{
				let	differenceMin, differenceMax;
				let edge;

				differenceMin = modelBoundingBox.min.clone().sub( center );
				differenceMax = modelBoundingBox.max.clone().sub( center );
				edge = Math.max(
					Math.abs( differenceMin.x * Math.cos( angle ) ),
					Math.abs( differenceMin.y ),
					Math.abs( differenceMin.z * Math.sin( angle ) ),
					Math.abs( differenceMax.x * Math.cos( angle ) ),
					Math.abs( differenceMax.y * Math.sin( angle ) ),
					Math.abs( differenceMax.z ) ) * 2.0;
				return ( edge );
			}

			function updateModelHelpers()
			{
				let edge;
				let	direction, center;
				let hipLeft, hipRight;
				let angle;

				updateModelBbox();
				hipLeft = getBonePosition( 101 );
				hipRight = getBonePosition( 111 );
				direction = hipLeft.clone().sub( hipRight ).normalize();
				angle = Math.PI * 0.5 + Math.atan2( direction.x, direction.z );

				center = getBonePosition( 0 );
				updateArrowHelpers( center, angle );
				
				edge = getIcosahedronEdge( center, angle );
				modelGuizmoHelper.position.set( center.x, center.y, center.z );
				modelGuizmoHelper.scale.set( edge, edge, edge );
				modelGuizmoHelper.rotation.set( 0, angle, 0 );

				edge = Math.sqrt( Math.pow( edge, 2.0 ) + Math.pow( edge * 0.618034, 2.0 ) );
				modelIcoHelper.scale.set( edge, edge, edge);
				modelIcoHelper.position.set( center.x, center.y, center.z );
				modelIcoHelper.rotation.set( 0, angle, 0 );
				return ;
			}

			function updateArrowHelpers( center, angle )
			{
				let euler;
				let positionSum;
				let sumX, sumY, sumZ;

				euler = new THREE.Euler( 0, angle + Math.PI, 0, 'XYZ' );
				positionSum = new THREE.Vector3( );
				for ( let i = 0; i < modelSkelHelper.bones.length; i++ )
					positionSum.add( getBonePosition( i ) );
				positionSum.divideScalar( modelSkelHelper.bones.length );
				positionSum.sub( center );

				sumX = positionSum.clone();
				sumX.projectOnVector( new THREE.Vector3( 1.0, 0.0, 0.0 ).applyEuler( euler ) );
				modelArrowHelperX.setLength( sumX.length() * 3.0, 0.0, 4.0 );
				modelArrowHelperX.setDirection( sumX.normalize() );
				modelArrowHelperX.position.set( center.x, center.y, center.z );

				sumY = positionSum.clone();
				sumY.projectOnVector( new THREE.Vector3( 0.0, 1.0, 0.0 ) );
				modelArrowHelperY.setLength( sumY.length() * 3.0, 0.0, 4.0 );
				modelArrowHelperY.setDirection( sumY.normalize() );
				modelArrowHelperY.position.set( center.x, center.y, center.z );

				sumZ = positionSum.clone();
				sumZ.projectOnVector( new THREE.Vector3( 0.0, 0.0, 1.0 ).applyEuler( euler ) );
				modelArrowHelperZ.setLength( sumZ.length() * 3.0, 0.0, 4.0 );
				modelArrowHelperZ.setDirection( sumZ.normalize() );
				modelArrowHelperZ.position.set( center.x, center.y, center.z );
				return ;
			}

			function updateModelConvexMesh()
			{
				let geometry;
				let positions;
				let vertices = [];

				/*
				modelMesh.traverse( function ( child )
				{
					if ( child.isMesh )
					{
						childGeometry = child.geometry.clone();
						childGeometry.deleteAttribute( 'normal' );
						childGeometry.deleteAttribute( 'uv' );
						positions = childGeometry.getAttribute( 'position' );
						for ( let i = 0, position; i < positions.count; i++ )
						{
							position = new THREE.Vector3();
							position.fromBufferAttribute( positions, i );
							child.boneTransform( i, position );
							vertices.push( position );
						}
					}
				} );
				*/

				geometry = new THREE.IcosahedronGeometry( 16.0, 2 );
				for (let i = 0, position; i < modelSkelHelper.bones.length; i++ )
				{
					position = getBonePosition( i );
					for (let j = 0; j < geometry.vertices.length; j++ )
						vertices.push( position.clone().add( geometry.vertices[ j ] ) );
				}
				modelConvexMesh.geometry = new ConvexGeometry( vertices );
				modelConvexMesh.geometry.needsUpdate = true;
				return ;
			}

			function render()
			{
//				stats.update();
				renderer.render( scene, camera );
				return ;
			}

			function animate()
			{
				let animation;
				let name;
				let settings;

				requestAnimationFrame( animate );
				if ( modelAnimMixer )
					modelAnimMixer.update( clock.getDelta() );
				updateModelConvexMesh();
				updateModelHelpers();
				render();
				return ;
			}
		</script>
	</body>
</html>