
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Continuum</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<div id="container" style="display: block; width: 100%; height: 620px;"></div>
		<div id="gui-container" style="position: absolute; top: 0px; left: 0px;"></div>

		<script defer type="module">
			import * as THREE from 'https://unpkg.com/three@0.121.1/build/three.module.js';
			import Stats from 'https://unpkg.com/three@0.121.1/examples/jsm/libs/stats.module.js';
			import { GUI } from 'https://unpkg.com/three@0.121.1/examples/jsm/libs/dat.gui.module.js';
			import { OrbitControls } from 'https://unpkg.com/three@0.121.1/examples/jsm/controls/OrbitControls.js';
			import { GLTFLoader } from 'https://unpkg.com/three@0.121.1/examples/jsm/loaders/GLTFLoader.js';
			import { FBXLoader } from 'https://unpkg.com/three@0.121.1/examples/jsm/loaders/FBXLoader.js';
			
			let container, clock, stats;
			let camera, controls, scene, renderer;
			let hemiLight, dirLight;
			let modelMesh, modelAnimMixer, modelSkeleton;
			let modelBoundingBox, modelIcoHelper;
			let modelGuizmoHelper, modelGridHelperX, modelGridHelperY, modelGridHelperZ;
			let modelArrowHelperX, modelArrowHelperY, modelArrowHelperZ;
			let guiSettings;

			const ui = {
				timeScale: 1.0,
			}

			init();
			animate();

			function loadModel( object )
			{
				modelMesh = object;

				modelAnimMixer = new THREE.AnimationMixer( modelMesh );
				modelAnimMixer.clipAction( modelMesh.animations[ 0 ] ).play();

				modelMesh.traverse( function ( child )
				{
					if ( child.isMesh )
					{
						child.castShadow = true;
						child.receiveShadow = true;
					}
				} );
				scene.add( modelMesh );

				modelSkeleton = new THREE.SkeletonHelper( modelMesh );
				modelSkeleton.visible = true;
				scene.add( modelSkeleton );
			}

			function setArrowHelpers()
			{
				modelArrowHelperX = new THREE.ArrowHelper( new THREE.Vector3( 1.0, 0.0, 0.0 ), new THREE.Vector3(), 20, 0xff0000 );
				modelArrowHelperY = new THREE.ArrowHelper( new THREE.Vector3( 0.0, 1.0, 0.0 ), new THREE.Vector3(), 20, 0xff0000 );
				modelArrowHelperZ = new THREE.ArrowHelper( new THREE.Vector3( 0.0, 0.0, 1.0 ), new THREE.Vector3(), 20, 0xff0000 );
				scene.add( modelArrowHelperX, modelArrowHelperY, modelArrowHelperZ );
				return ;
			}

			function setGuizmoHelper()
			{
				let gridHelperX;
				let gridHelperY;
				let gridHelperZ; 

				modelGuizmoHelper = new THREE.Group();
				gridHelperX = new THREE.GridHelper( 1, 2, 0xff0000, 0xe0e0e0 );
				gridHelperX.scale.set( 1.0, 1.0, 0.618034 );
				modelGuizmoHelper.add( gridHelperX );

				gridHelperY = new THREE.GridHelper( 1, 2, 0xff0000, 0xe0e0e0 );
				gridHelperY.rotation.x = Math.PI / 2.0;
				gridHelperY.scale.set( 0.618034, 1.0, 1.0 );
				modelGuizmoHelper.add( gridHelperY );

				gridHelperZ = new THREE.GridHelper( 1, 2, 0xff0000, 0xe0e0e0 );
				gridHelperZ.rotation.z = Math.PI / 2.0;
				gridHelperZ.scale.set( 0.618034, 1.0, 1.0 );
				modelGuizmoHelper.add( gridHelperZ );
				scene.add( modelGuizmoHelper );
			}

			function setModelHelpers()
			{
				let modelBoundingBoxHelper;
				let geometry;
				let wireframe;

				setGuizmoHelper();

				modelBoundingBox = new THREE.Box3();
				modelBoundingBoxHelper = new THREE.Box3Helper( modelBoundingBox, new THREE.Color( 0, 255, 0 ) );

				geometry = new THREE.IcosahedronGeometry( 0.5, 0 );
				wireframe = new THREE.WireframeGeometry( geometry );	
				modelIcoHelper = new THREE.LineSegments( wireframe );
				modelIcoHelper.material.depthTest = false;
				modelIcoHelper.material.opacity = 0.75;
				modelIcoHelper.material.transparent = true;
				scene.add( modelIcoHelper );

				setArrowHelpers();
				return ;
			}

			function modifyTimeScale( speed )
			{
				modelAnimMixer.timeScale = speed;
				return ;
			}

			function createGUI()
			{
				let gui;
				let folderAnimation;

				gui = new GUI();
				document.getElementById( 'gui-container' ).appendChild( gui.domElement );
				folderAnimation = gui.addFolder( 'Animation settings' );
				folderAnimation.add( ui, 'timeScale', 0.01, 2.0, 0.01 ).listen().onChange( modifyTimeScale );
				return ;
			}

			function init()
			{
				let modelLoader;
				let	floorMesh;

				container = document.getElementById( 'container' );
				clock = new THREE.Clock();

				camera = new THREE.PerspectiveCamera( 30, container.clientWidth / container.clientHeight, 1, 5000 );
				camera.position.set( 0, 240, 1200 );
				controls = new OrbitControls( camera, container );
				controls.target.set( 0, 80, 0 );
				controls.update();

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xf8f8ff );
				scene.fog = new THREE.Fog( 0xf8f8ff, 1200, 2000 );

				hemiLight = new THREE.HemisphereLight( 0xf8f8ff, 0x404048 );
				hemiLight.position.set( 0, 240, 0 );
				scene.add( hemiLight );

				dirLight = new THREE.DirectionalLight( 0xf8f8ff );
				dirLight.position.set( 0, 240, 120 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.top = 160;
				dirLight.shadow.camera.bottom = - 80;
				dirLight.shadow.camera.left = - 120;
				dirLight.shadow.camera.right = 120;
				scene.add( dirLight );

				floorMesh = new THREE.Mesh( new THREE.PlaneGeometry( 2400, 2400 ), new THREE.MeshPhongMaterial( { color: 0xffffff, depthWrite: false } ) );
				floorMesh.rotation.x = -Math.PI / 2.0;
				floorMesh.receiveShadow = true;
				scene.add( floorMesh );

				const grid = new THREE.GridHelper( 2000, 20, 0xf0f0f0, 0xf0f0f0 );
				scene.add( grid );

				const loader = new FBXLoader();
				loader.load( 'models/fbx/Samba Dancing.fbx', function ( object ) {
					loadModel( object );
					setModelHelpers();
				} );

				createGUI();

				stats = new Stats();
				container.appendChild( stats.dom );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( container.clientWidth, container.clientHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1.0;
				renderer.shadowMap.enabled = true;

				container.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );
				return ;
			}

			function onWindowResize()
			{
				camera.aspect = container.clientWidth / container.clientHeight;
				camera.updateProjectionMatrix();	
				renderer.setSize( container.clientWidth, container.clientHeight );
				return ;
			}

			function updateModelBbox()
			{
				let min;
				let max;

				min = new THREE.Vector3( Infinity, Infinity, Infinity );
				max = min.clone().multiplyScalar( -1 );
				for (let i = 0, position; i < modelSkeleton.bones.length; i++ )
				{
					position = new THREE.Vector3();
					modelSkeleton.bones[ i ].getWorldPosition( position );
					if ( position.x < min.x ) min.x = position.x;
					if ( position.y < min.y ) min.y = position.y;
					if ( position.z < min.z ) min.z = position.z;
					if ( position.x > max.x ) max.x = position.x;
					if ( position.y > max.y ) max.y = position.y;
					if ( position.z > max.z ) max.z = position.z;
				}
				modelBoundingBox.set( min, max );
				return ;
			}

			function getIcosahedronEdge( center, angle )
			{
				let	differenceMin;
				let differenceMax;
				let edge;

				differenceMin = modelBoundingBox.min.clone().sub( center );
				differenceMax = modelBoundingBox.max.clone().sub( center );
				edge = Math.max(
					Math.abs( differenceMin.x * Math.cos( angle ) ),
					Math.abs( differenceMin.y ),
					Math.abs( differenceMin.z * Math.sin( angle ) ),
					Math.abs( differenceMax.x * Math.cos( angle ) ),
					Math.abs( differenceMax.y * Math.sin( angle ) ),
					Math.abs( differenceMax.z ) ) * 2.0;
				return ( edge );
			}

			function updateModelHelpers()
			{
				let bone;
				let edge;
				let	center;
				let hipLeft;
				let hipRight;
				let direction;
				let angle;

				bone = modelSkeleton.bones[ 0 ];
				center = new THREE.Vector3();
				bone.getWorldPosition( center );

				updateModelBbox();
				bone = modelSkeleton.bones[ 101 ];
				hipLeft = new THREE.Vector3();
				bone.getWorldPosition( hipLeft );
				bone = modelSkeleton.bones[ 111 ];
				hipRight = new THREE.Vector3();
				bone.getWorldPosition( hipRight );
				direction = hipLeft.clone().sub( hipRight ).normalize();
				angle = Math.PI * 0.5 + Math.atan2( direction.x, direction.z );
				edge = getIcosahedronEdge( center, angle );

				modelGuizmoHelper.position.set( center.x, center.y, center.z );
				modelGuizmoHelper.scale.set( edge, edge, edge );
				modelGuizmoHelper.rotation.set( 0, angle, 0 );

				edge = Math.sqrt( Math.pow( edge, 2.0 ) + Math.pow( edge * 0.618034, 2.0 ) );
				modelIcoHelper.scale.set( edge, edge, edge);
				modelIcoHelper.position.set( center.x, center.y, center.z );
				modelIcoHelper.rotation.set( 0, angle, 0 );

				updateArrowHelpers( center, angle );
				return ;
			}

			function updateArrowHelpers( center, angle )
			{
				let euler;
				let positionSum;
				let sumX, sumY, sumZ;

				euler = new THREE.Euler( 0, angle + Math.PI, 0, 'XYZ' );
				positionSum = new THREE.Vector3( );
				for ( let l = 0, position; l < modelSkeleton.bones.length; l++ )
				{
					position = new THREE.Vector3();
					modelSkeleton.bones[ l ].getWorldPosition( position );
					positionSum.add( position );
				}
				positionSum.divideScalar( modelSkeleton.bones.length );
				positionSum.sub( center );

				sumX = positionSum.clone();
				sumX.projectOnVector( new THREE.Vector3( 0.0, 1.0, 0.0 ) );
				modelArrowHelperX.setLength( sumX.length() * 3.0, 0.0, 4.0 );
				modelArrowHelperX.setDirection( sumX.normalize() );
				modelArrowHelperX.position.set( center.x, center.y, center.z );

				sumY = positionSum.clone();
				sumY.projectOnVector( new THREE.Vector3( 0.0, 0.0, 1.0 ).applyEuler( euler ) );
				modelArrowHelperY.setLength( sumY.length() * 3.0, 0.0, 4.0 );
				modelArrowHelperY.setDirection( sumY.normalize() );
				modelArrowHelperY.position.set( center.x, center.y, center.z );

				sumZ = positionSum.clone();
				sumZ.projectOnVector( new THREE.Vector3( 1.0, 0.0, 0.0 ).applyEuler( euler ) );
				modelArrowHelperZ.setLength( sumZ.length() * 3.0, 0.0, 4.0 );
				modelArrowHelperZ.setDirection( sumZ.normalize() );
				modelArrowHelperZ.position.set( center.x, center.y, center.z );
				return ;
			}

			function render()
			{
				stats.update();
				renderer.render( scene, camera );
				return ;
			}

			function animate()
			{
				let animation;
				let name;
				let settings;

				requestAnimationFrame( animate );
				if ( modelAnimMixer )
					modelAnimMixer.update( clock.getDelta() );
				updateModelHelpers();
				render();
				return ;
			}
		</script>
	</body>
</html>